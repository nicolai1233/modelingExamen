/*
 * generated by Xtext 2.24.0
 */
package org.xtext.example.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.exameLanguage.X21
import org.xtext.example.exameLanguage.Function
import java.util.ArrayList
import org.xtext.example.exameLanguage.Input
import org.xtext.example.exameLanguage.Node
import org.xtext.example.exameLanguage.Stream
import org.xtext.example.exameLanguage.DataDecl
import org.xtext.example.exameLanguage.Parameter
import org.xtext.example.exameLanguage.Expresion
import org.xtext.example.exameLanguage.MathExp
import org.xtext.example.exameLanguage.Numbers
import org.xtext.example.exameLanguage.Plus
import org.xtext.example.exameLanguage.Minus
import org.xtext.example.exameLanguage.Mult
import org.xtext.example.exameLanguage.Div
import org.xtext.example.exameLanguage.Parenthesis
import org.xtext.example.exameLanguage.Datatype
import org.xtext.example.exameLanguage.None
import org.xtext.example.exameLanguage.Let
import org.xtext.example.exameLanguage.IfThen
import org.xtext.example.exameLanguage.New
import org.xtext.example.exameLanguage.Dataa
import org.xtext.example.exameLanguage.Element
import org.xtext.example.exameLanguage.Para

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ExameLanguageGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		val X21 modelInstance = resource.allContents.filter(X21).next
		
		
		
		val funkList = new ArrayList<Function>
		funkList.addAll(modelInstance.declaration.filter(Function))
		
		
		
		val inpuntList = new ArrayList<Input>
		inpuntList.addAll(modelInstance.declaration.filter(Input))
		
		val nodeList = new ArrayList<Node>
		nodeList.addAll(modelInstance.declaration.filter(Node))
		
		
		val streamList = new ArrayList<Stream>
		streamList.addAll(modelInstance.declaration.filter(Stream))

		val dataDeclList = new ArrayList<DataDecl>
		dataDeclList.addAll(modelInstance.declaration.filter(DataDecl))

		val parameterList = new ArrayList<Para>
		parameterList.addAll(modelInstance.declaration.filter(Para))
		
		
				
		
		
		
		
		
		
		
		
		
		generateE21File(modelInstance,fsa,funkList,inpuntList,nodeList,streamList,dataDeclList,parameterList )
		
		

	}
	
	
	def generateE21File(X21 x21, IFileSystemAccess2 fsa ,ArrayList<Function> funkList ,ArrayList<Input> inpuntList,ArrayList<Node> nodeList,ArrayList<Stream> streamList,ArrayList<DataDecl> dataDeclList,ArrayList<Para> parameterList ){
		
		fsa.generateFile(x21.name+"gen/"+x21.name+"Main.java", gennerateMain(x21,funkList,inpuntList,nodeList,streamList,dataDeclList,parameterList  ))
		
	}
	

	def CharSequence gennerateMain(X21 x21, ArrayList<Function> funkList ,ArrayList<Input> inpuntList,ArrayList<Node> nodeList,ArrayList<Stream> streamList,ArrayList<DataDecl> dataDeclList,ArrayList<Para> parameterList){
		'''
		package «x21.name»gen;
		import libx21.*;
		import java.util.function.Function;
		import java.util.List;
		
		public class «x21.name»Main extends GenericMainX21{
			
			
			«FOR a: parameterList»
			«parametersGenerator(a)»
			«ENDFOR»
			
			«FOR a: funkList»
			«funktionGeneration(a)»
			«ENDFOR»
			
			«FOR a: inpuntList»
			«inputGeneration(a)»
			«ENDFOR»
			
			«FOR a: nodeList»
			«nodeGeneratrion(a,funkList)»
			«ENDFOR»
			
			«FOR a: streamList»
			«streamGeneratrtion(a)»
			«ENDFOR»			
			
			
			«streamName1(streamList)»
			
			
		
		«initializeNetworkGenerat(streamList)»
		protected void initializeNodes() {
			«initializeNodes(inpuntList,nodeList)»
		}
		
		
		}
		
		
		
		
		'''
	}
	
	def parametersGenerator(Para parameter){
		'''
		private «IF parameter.type.type !== null»«IF parameter.type.type == "int"»Integer«ELSEIF parameter.type.type == "string"»String«ENDIF»«ELSE »«parameter.type.name»«ENDIF» _«parameter.name»;
		public void setParameter«parameter.name.toFirstUpper»(«IF parameter.type.type !== null»«IF parameter.type.type == "int"»Integer«ELSEIF parameter.type.type == "string"»String«ENDIF»«ELSE »«parameter.type.name»«ENDIF» value){
			_«parameter.name»= value;
		} 
		
		
		
		'''
	}	


	def initializeNodes(ArrayList<Input> inplist, ArrayList<Node> nodeList){
		'''
		«inputNode(inplist)»
		«nodeNode(nodeList)»
		'''
	}
	
	def nodeNode(ArrayList<Node> node){
		var str = ""
		for(Node a : node){
			str = str + "super.addNode(node_"+a.name+");\n"
		}
		str
	}
	
	
	
	def inputNode(ArrayList<Input> input){
		var str = ""
		for(Input a : input){
			str = str + "super.addNode(node_"+a.name+");\n"
		}
		str
	}
	
	def funktionGeneration(Function funk){
	'''
	private Object fun_«funk.name»(Object val){
		return funimpl_«funk.name»((«IF funk.lambda.type.type == "int" »Integer«ELSEIF funk.lambda.type.type == "string"»String«ELSE»«funk.lambda.type.name»«ENDIF»)val);
	}
	«System::out.println(funk.lambda.type)»
	private Object funimpl_«funk.name»(«IF funk.lambda.type.type == "int" »Integer«ELSEIF funk.lambda.type.type == "string"»String«ELSE»«funk.lambda.type.name»«ENDIF» _«funk.lambda.name»)
	{
		return «funk.lambda.exp.testing»;	
	}
	
	'''
	
		
	}
	
	def inputGeneration(Input input){
		'''
		private ComputeNode<Object,Object> node_«input.name» = new InputNode<Object>();
		public void input«input.name.toFirstUpper»(«IF input.type.type == "int" »Integer«ELSEIF input.type.type == "string"»String«ELSE»«input.type.name»«ENDIF» input){
			node_«input.name».put(input);
		}
		
		'''
	}
	
	def nodeGeneratrion(Node node,ArrayList<Function> funkList){
		'''
		private ComputeNode<Object,Object> node_«node.name» = new AbstractComputeNode<Object,Object>() {
			protected Object function(Object input){
			 «FOR a:funkList»«IF node.name1 !== null»«IF node.name1.name == a.name»
			 	return fun_«node.name1.name»(input);
			 «ENDIF»
			 «ENDIF»
			 «IF node.lambda !==null»
			 protected «IF node.lambda.type.type !== null»«IF node.lambda.type.type == "string"»String «ELSEIF node.lambda.type.type == "int"»Integer «ELSE»«node.lambda.type.name» «ENDIF»mild(«IF node.lambda.type.type !== null»«node.lambda.type.type»«ELSE»«node.lambda.type.name»«ENDIF» _«node.lambda.name»){
			 	return «node.lambda.exp.testing»
			 	} 
			 	return mild(input);
			 «ENDIF»
				«ENDIF»
			 «ENDFOR»
			} 
		};
		
		'''
	}
	
	def streamGeneratrtion(Stream stream){
		'''
		«FOR a: stream.toElement»
		«IF a.element.out !== null»
		private OutputNode<Object> node_«a.element.out» = new OutputNode<Object>();
		public List<Object> get«a.element.out.toFirstUpper»() { return node_«a.element.out».getData(); }
		«ENDIF»
		«ENDFOR»
		«FOR a: stream.toElement»
		«FOR ele : a.element1»
		«IF ele.out !== null»
		private OutputNode<Object> node_«ele.out» = new OutputNode<Object>();
		public List<Object> get«ele.out.toFirstUpper»() { return node_«ele.out».getData(); }
		«ENDIF»
		«ENDFOR»
		«ENDFOR»
		
		'''
	}
	
	def initializeNetworkGenerat(ArrayList<Stream> streamList){
		'''
		protected void initializeNetwork() {
			
			«addOutputnode(streamList)»
		}
		
		'''
	} 
	
	def CharSequence createName1Imp(Stream stream, int n){
		'''
		private ComputeNode <Object,Object> node_«n» = new AbstractComputeNode<Object,Object>() {
			protected Object function(Object input) {
				return fun_«FOR a: stream.toElement»«IF a.element.name1 !== null»«a.element.name1»«ELSE»«FOR b : a.element1»«IF b.name1 !== null»«b.name1»«ENDIF»«ENDFOR»(input);«ENDIF»«ENDFOR»	
			}
		};
		
		'''
	}
	
	def checkForTrue(Stream stream){
		var bool = false
		for(i:0..<stream.toElement.size){
			for(j:0..<stream.toElement.get(i).element1.size){
				if(stream.toElement.get(i).element1.get(j).name1 !== null){
					bool = true
				}
			}
		}
		bool
	}
	
	
	def CharSequence streamName1(ArrayList<Stream> list){
		var n = 0
		var s = ''''''
		for(Stream stream : list){
			for(i:0..<stream.toElement.size){
				System.out.println("her er jeg pls"+stream.toElement.get(i).element.name1)
				if(stream.toElement.get(i).element.name1 !== null){
					s= s+createName1Imp(stream,n)
					n=n+1
				}else if(checkForTrue(stream)){
					s=s+createName1Imp(stream,n)
					n=n+1
				}
				
			}
		}
		s
		
	}
	
	
	def addOutputnode(ArrayList<Stream> list){
		var str = ""
		for(Stream stream: list){
			for(i:0..<stream.toElement.size ){
				if(i == 0){
					str = str + "node_"+stream.name+".addOutputNode(node_"+stream.toElement.get(i).element.name+");\n"
					for(j:0..<stream.toElement.get(i).element1.size){
						str = str + "node_"+stream.name+".addOutputNode(node_"+stream.toElement.get(i).element1.get(j).name+");\n"
					}
				}System.out.println("value of i+1 and the value of array "+ (i+1)+" "+ stream.toElement.size)
				if(i+1<stream.toElement.size && i !== 0){
					str = str + "node_"+stream.toElement.get(i-1).element.name+".addOutputNode(node_"+stream.toElement.get(i).element.name+");\n"
					for(j:0..<stream.toElement.get(i).element1.size){
						str = str + "node_"+stream.toElement.get(i-1).element.name+".addOutputNode(node_"+stream.toElement.get(i).element1.get(j).name+");\n"
					}
				}else if (i!==0){
					str = str + "node_"+stream.toElement.get(i-1).element.name+".addOutputNode(node_"+stream.toElement.get(i).element.out+");\n"
				    for(j:0..<stream.toElement.get(i).element1.size){
						str = str + "node_"+stream.toElement.get(i-1).element.name+".addOutputNode(node_"+stream.toElement.get(i).element1.get(j).out+");\n"
					}
				}
				
				
			}
		}
		str
		
	}
	
	def int generate(MathExp gen) {
		gen.exp.generateExp
	}
		
	def dispatch int generateExp(Expresion exp) { exp.exp1.generateExp }
	def dispatch int generateExp(Numbers exp) { exp.value }
	
	def dispatch int generateExp(Plus exp) { 
		exp.exp1.generateExp+exp.exp2.generateExp
	}
	def dispatch int generateExp(Minus exp) {
		exp.exp1.generateExp-exp.exp2.generateExp
	}
	
	def dispatch int generateExp(Mult exp) { 
		exp.exp1.generateExp*exp.exp2.generateExp
	}
	def dispatch int generateExp(Div exp) { 
		exp.exp1.generateExp/exp.exp2.generateExp
	}
	
	def dispatch int generateExp(Parenthesis exp) { exp.exp.generateExp 
	
	}
		
	def String testing(MathExp exp){
		exp.exp.generateString
		
	}
		
	def dispatch String generateString(Expresion exp){
		exp.exp1.generateString
	}
	def dispatch String generateString(Plus exp){
		"("+exp.exp1.generateString+") + ("+exp.exp2.generateString+")"
	}
		def dispatch String generateString(Minus exp){
		"("+exp.exp1.generateString+") - ("+exp.exp2.generateString+")"
	}
		def dispatch String generateString(Mult exp){
		"("+exp.exp1.generateString+") * ("+exp.exp2.generateString+")"
	}
		def dispatch String generateString(Div exp){
		"("+exp.exp1.generateString+") / ( "+exp.exp2.generateString+")"
	}
		def dispatch String generateString(Numbers exp){
			Integer.toString(exp.value)
	}
		def dispatch String generateString(Dataa exp){
			"( _"+exp.name+" )"
	}
	def dispatch String generateString(Parenthesis exp) {
		 "("+exp.exp.generateString+")" 
	
	}
		
	
	
	
		

}
